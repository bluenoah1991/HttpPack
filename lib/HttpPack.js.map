{"version":3,"sources":["../src/HttpPack.js"],"names":["Protocol","HttpPack","options","undefined","storage","packet","qos","QoS0","retryTimes","retryPacket","cloneDeep","timestamp","add","unix","Encode","msgType","identifier","payload","callback","MSG_TYPE_SEND","QoS1","replyPacket","MSG_TYPE_ACK","savePacket","then","bind","QoS2","receivePacket","MSG_TYPE_RECEIVED","confirmPacket","MSG_TYPE_RELEASE","releasePacket","MSG_TYPE_COMPLETED","packets","buffers","map","buffer","Buffer","concat","length","offset","Decode","push","totalLength","generateId","id","respondPackets","unconfirmedPacket","waitHandles","generateRetryPacket","Promise","all","combinePacket","body","nullString","resolve","splitBuffer","handlePacket"],"mappings":"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","file":"HttpPack.js","sourcesContent":["import _ from 'lodash';\nimport moment from 'moment';\n\nimport MemoryStorage from './MemoryStorage';\nimport * as Protocol from './Protocol';\n\nexport default class HttpPack {\n    constructor(options){\n        if(options == undefined){\n            options = {};\n        }\n        this.storage = options['storage'] || new MemoryStorage();\n    }\n\n    generateRetryPacket(packet){\n        if(packet.qos == Protocol.QoS0){\n            return null;\n        } else {\n            if(packet.retryTimes != undefined && packet.retryTimes > 0) {\n                let retryPacket = _.cloneDeep(packet);\n                retryPacket.retryTimes++;\n                retryPacket.timestamp = moment().add(retryPacket.retryTimes * 5, 's').unix();\n                return retryPacket;\n            } else {\n                let retryPacket = Protocol.Encode(\n                    packet.msgType, packet.qos, 1, packet.identifier, packet.payload);\n                retryPacket.retryTimes = 1;\n                retryPacket.timestamp = moment().add(retryPacket.retryTimes * 5, 's').unix();\n                return retryPacket;\n            }\n        }\n    }\n\n    handlePacket(packet, callback){\n        if(packet.msgType == Protocol.MSG_TYPE_SEND){\n            if(packet.qos == Protocol.QoS0){\n                callback(packet.payload);\n                return null;\n            } else if(packet.qos == Protocol.QoS1){\n                let replyPacket = Protocol.Encode(Protocol.MSG_TYPE_ACK, Protocol.QoS0, 0, packet.identifier);\n                return this.storage.savePacket(replyPacket).then(function(){\n                    callback(packet.payload);\n                }.bind(this));\n            } else if(packet.qos == Protocol.QoS2){\n                return this.storage.receivePacket(packet.identifier, packet.payload).then(function(){\n                    let replyPacket = Protocol.Encode(Protocol.MSG_TYPE_RECEIVED, Protocol.QoS0, 0, packet.identifier);\n                    return this.storage.savePacket(replyPacket);\n                }.bind(this));\n            }\n        } else if(packet.msgType == Protocol.MSG_TYPE_ACK){\n            return this.storage.confirmPacket(packet.identifier);\n        } else if(packet.msgType == Protocol.MSG_TYPE_RECEIVED){\n            return this.storage.confirmPacket(packet.identifier).then(function(){\n                let replyPacket = Protocol.Encode(Protocol.MSG_TYPE_RELEASE, Protocol.QoS1, 0, packet.identifier);\n                return this.storage.savePacket(replyPacket);\n            }.bind(this));      \n        } else if(packet.msgType == Protocol.MSG_TYPE_RELEASE){\n            return this.storage.releasePacket(packet.identifier).then(function(payload){\n                if(payload != undefined){\n                    callback(payload);\n                }\n                let replyPacket = Protocol.Encode(Protocol.MSG_TYPE_COMPLETED, Protocol.QoS0, 0, packet.identifier);\n                return this.storage.savePacket(replyPacket);\n            }.bind(this));\n        } else if(packet.msgType == Protocol.MSG_TYPE_COMPLETED){\n            return this.storage.confirmPacket(packet.identifier);\n        }\n    }\n\n    combinePacket(packets){\n        let buffers = _.map(packets, function(packet){\n            return packet.buffer;\n        }.bind(this));\n        return Buffer.concat(buffers);\n    }\n\n    splitBuffer(buffer){\n        let packets = [];\n        let length = buffer.length;\n        let offset = 0;\n        while(offset < buffer.length){\n            let packet = Protocol.Decode(buffer, offset);\n            packets.push(packet);\n            offset += packet.totalLength;\n        }\n        return packets;\n    }\n\n    // Public method\n\n    commit(payload, qos = Protocol.QoS0){\n        if(typeof payload == 'string'){\n            payload = new Buffer(payload, 'utf-8');\n        }\n        return this.storage.generateId().then(function(id){\n            let packet = Protocol.Encode(\n                Protocol.MSG_TYPE_SEND, qos, 0, id, payload);\n            packet.timestamp = moment().unix();\n            return this.storage.savePacket(packet);\n        }.bind(this));\n    }\n\n    generateBody(){\n        let respondPackets = this.storage.unconfirmedPacket(5);\n        return respondPackets.then(function(packets){\n            let waitHandles = _.map(packets, function(packet){\n                let retryPacket = this.generateRetryPacket(packet);\n                if(retryPacket != undefined){\n                    return this.storage.savePacket(retryPacket).then(function(){\n                        return packet;\n                    });\n                }\n                return packet;\n            }.bind(this));\n            return Promise.all(waitHandles).then(function(packets){\n                return this.combinePacket(packets);\n            }.bind(this));\n        }.bind(this));\n    }\n\n    parseBody(body, callback){\n        if(body == undefined){\n            let nullString = new Buffer('', 'utf-8');\n            return Promise.resolve(nullString);\n        }\n        body = new Buffer(body, 'utf-8');\n        let packets = this.splitBuffer(body);\n        let waitHandles = _.map(packets, function(packet){\n            return this.handlePacket(packet, callback);\n        }.bind(this));\n        return Promise.all(waitHandles);\n    }\n}"]}